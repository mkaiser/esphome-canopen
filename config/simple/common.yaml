esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# TODO switch here between can_bus_esp32 and can_bus_mcp2515
# canbus:
#   - platform: esp32_can
#     setup_priority: 1000
#     id: can_bus_esp32
#     tx_pin: GPIO7
#     rx_pin: GPIO6
#     can_id: 0
#     bit_rate: 250kbps

spi:
  id: McpSpi
  clk_pin: GPIO10
  mosi_pin: GPIO7
  miso_pin: GPIO6
canbus:
  - platform: mcp2515
    id: can_bus_mcp2515
    clock: 8MHz
    spi_id: McpSpi
    cs_pin: GPIO2
    can_id: 0
    use_extended_id: false
    bit_rate: 10kbps

esphome:
  name: can-node-${node_id}

  on_boot:
    priority: 600
    then:
      - logger.log: "on_boot"
      - delay: 1s
      - lambda: id(can_gate).trig_tpdo();

canopen:
  setup_priority: 999
  id: can_gate
  # TODO switch here between can_bus_esp32 and can_bus_mcp2515
  canbus_id: can_bus_mcp2515
  # canbus_id: can_bus_esp32

  node_id: ${node_id}
  sw_version: 0.0.1
  hw_version: 0.0.1

  heartbeat_interval: 1s
  heartbeat_clients:
    - node_id: ${peer_node_id}
      timeout: 2s

  on_hb_consumer_event:
    then:
      - lambda: |
          ESP_LOGW("canopen", "missed heartbeat from node %d", node_id);

  entities:
    - id: gpio_led
      index: 1
      tpdo: 0
      rpdo:
        - node_id: ${peer_node_id}
          tpdo: 0
          offset: 0

# Enable logging
logger:
  level: INFO
  logs:
    timer_driver: INFO
    # debug: INFO
    canbus: INFO
    sensor: INFO
    text_sensor: INFO
    can_driver: INFO
    # canopen: INFO
    wifi: WARN

# Enable Home Assistant API
api:
  password: ""
  reboot_timeout: 0s

ota:
  password: ""
  safe_mode: false

external_components:
  - source: github://mrk-its/esphome-canopen
    refresh: 10s
# external_components:
#   - source: ../components

button:
  - platform: factory_reset
    name: Restart with Factory Default Settings

sensor:
  - platform: uptime
    id: uptime_sensor
    name: "Uptime"

  - platform: template
    name: "Arb Lost Count"
    id: can_status_arb_lost
    lambda: return id(can_gate).status.arb_lost;
    accuracy_decimals: 0
    update_interval: 5s

  - platform: template
    name: "Bus Error Count"
    id: can_status_bus_err
    lambda: return id(can_gate).status.bus_err;
    accuracy_decimals: 0
    update_interval: 5s

  - platform: template
    name: "Tx Err"
    id: can_status_tx_err
    lambda: return id(can_gate).status.tx_err;
    accuracy_decimals: 0
    update_interval: 5s

  - platform: template
    name: "Rx Err"
    id: can_status_rx_err
    lambda: return id(can_gate).status.rx_err;
    accuracy_decimals: 0
    update_interval: 5s

  - platform: template
    name: "Tx Failed"
    id: can_status_tx_failed
    lambda: return id(can_gate).status.tx_failed;
    accuracy_decimals: 0
    update_interval: 5s

  - platform: template
    name: "Rx Miss"
    id: can_status_rx_miss
    lambda: return id(can_gate).status.rx_miss;
    accuracy_decimals: 0
    update_interval: 5s

  - platform: template
    name: "Missed Node ${peer_node_id} Heartbeats"
    id: can_status_missed_heartbeats
    lambda: return id(can_gate).get_heartbeat_events(${peer_node_id});
    accuracy_decimals: 0
    update_interval: 10s

text_sensor:
  - platform: template
    name: "CANOpen Status"
    id: canopen_status
    lambda: |
      static std::string states[] = {"STOPPED", "RUNNING", "BUS_OFF", "RECOVERING"};
      return states[id(can_gate).status.state];
    update_interval: 5s
    on_value:
      - if:
          condition:
            for:
              time: 60s
              condition:
                text_sensor.state:
                  id: canopen_status
                  state: BUS_OFF
          then:
            - logger.log:
                level: WARN
                format: "Bus off for 60s, resetting"
            - lambda: id(can_gate).initiate_recovery();
      - if:
          condition:
            for:
              time: 30s
              condition:
                text_sensor.state:
                  id: canopen_status
                  state: STOPPED
          then:
            - logger.log:
                level: WARN
                format: "starting"
            - lambda: id(can_gate).start();

switch:
  - platform: gpio
    name: "Led"
    id: gpio_led
    pin: GPIO0

binary_sensor:
  - platform: gpio
    name: "GPIO binary sensor"
    id: gpio_binary_sensor
    pin:
      number: GPIO4 # see spring clamps:  Pin #1 (near K1) is 3V3, Pin #2 GND,  Pin 3 is GPIO4 with pullup to 3V3 .... Pin 6 is near alive label
      inverted: true
    on_click:
      - switch.toggle: gpio_led
